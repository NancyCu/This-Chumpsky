<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CFG → CNF Converter (Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js"></script>
  <style>
    body {
      font-family: system-ui;
      padding: 1rem;
      max-width: 42rem;
      margin: auto;
      background: #1e1e1e;
      color: #ddd;
    }
    textarea {
      width: 100%;
      background: #111;
      color: #ddd;
      border: 1px solid #555;
    }
    button {
      background: #333;
      color: #ddd;
      border: 1px solid #555;
      padding: 0.5rem 1rem;
      margin: 0.25rem 0;
    }
    pre {
      padding: 1rem;
      background: #2b2b2b;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>CFG → CNF Converter (Pyodide)</h1>
  <textarea id="src" rows="6">S -> ASA | aB
A -> B | S
B -> b | ε</textarea><br>
  <button id="run">Convert to CNF</button>
  <button id="gen">Generate Words</button>
  <pre id="out"></pre>
  <pre id="words"></pre>

<script type="module">
/* ========== 1 ▸ spin-up Python in the browser ========== */
const pyodide = await loadPyodide();

/* ========== 2 ▸ full CNF engine (Python) ========== */
const pythonCode = `
import re
from collections import defaultdict, deque

# ─── tiny tokenizer that works with or without spaces ─────────────
def _tokenize(rh_side: str):
    """
    Turn 'ASB', 'A1B', 'bb' … into ['A','S','B'], ['A1','B'], ['b','b'] …
    Skips any whitespace in the RHS.
    """
    out, i = [], 0
    while i < len(rh_side):
        c = rh_side[i]
        if c.isspace():                     # ignore spaces
            i += 1; continue
        if c.isupper():                     # VARIABLE (capital + digits)
            j = i + 1
            while j < len(rh_side) and rh_side[j].isdigit():
                j += 1
            out.append(rh_side[i:j])        # e.g. 'A', 'A1', ...
            i = j
        else:                               # single-char terminal
            out.append(c)                   # e.g. 'a', 'b'
            i += 1
    return out

# ─── Parsing ────────────────────────────────────────────
def parse_cfg(text):
    g = defaultdict(list)
    arrow = re.compile(r'\\s*(->|→)\\s*')
    for line in text.strip().splitlines():
        if not line.strip():
            continue
        m = arrow.split(line, maxsplit=1)
        if len(m) < 3:
            continue
        left, right = m[0].strip(), m[2].strip()
        for prod in right.split('|'):
            prod = prod.strip()
            
            if prod in ('ε', 'E', '', '𝜺'):  # Recognize all ε variants

                g[left].append(['ε'])
                continue
            symbols = _tokenize(prod)
            g[left].append(symbols)
    return dict(g)

def format_grammar(g):
    return "\\n".join(
        f"{A} -> " + " | ".join("".join(p) for p in g[A])
        for A in g
    )

# ─── ε-removal ──────────────────────────────────────────
def remove_null_productions(g, start):
    nullable = {A for A, P in g.items() if ['ε'] in P}
    changed = True
    while changed:
        changed = False
        for A, P in g.items():
            if A in nullable:
                continue
            if any(all(s in nullable for s in p) for p in P):
                nullable.add(A); changed = True
    new = defaultdict(list)
    for A, P in g.items():
        for p in P:
            if p == ['ε']:
                continue
            pos = [i for i,s in enumerate(p) if s in nullable]
            for mask in range(1 << len(pos)):
                q = [s for i,s in enumerate(p)
                       if not (i in pos and (mask >> pos.index(i)) & 1)]
                if not q and A != start:
                    continue
                if q not in new[A]:
                    new[A].append(q or ['ε'])
    return dict(new)

# ─── unit-removal ───────────────────────────────────────
def remove_unit_productions(g):
    new = defaultdict(list)
    for A in g:
        queue, seen = [A], set()
        while queue:
            B = queue.pop(0)
            for p in g[B]:
                if len(p)==1 and p[0] in g:
                    if p[0] not in seen:
                        queue.append(p[0]); seen.add(p[0])
                else:
                    if p not in new[A]:
                        new[A].append(p)
    return dict(new)

# ─── useless-symbol removal ─────────────────────────────
def remove_useless_symbols(g, start):
    generating = set()
    changed = True
    while changed:
        changed = False
        for A,P in g.items():
            if A in generating:
                continue
            if any(all(s not in g or s in generating for s in p) for p in P):
                generating.add(A); changed = True
    g = {A:[p for p in P
            if all(s not in g or s in generating for s in p)]
         for A,P in g.items() if A in generating}

    reachable, queue = set(), [start]
    while queue:
        A = queue.pop(0)
        if A in reachable:
            continue
        reachable.add(A)
        for p in g.get(A, []):
            for s in p:
                if s in g and s not in reachable:
                    queue.append(s)
    return {A:P for A,P in g.items() if A in reachable}

# ─── CNF conversion (wrap-all-terminals + right-binarise) ─
def convert_to_cnf(g, start):
    wrapped, term_map, tid = defaultdict(list), {}, 1

    def term_var(t):
        nonlocal tid
        if t not in term_map:
            term_map[t] = f"T{tid}"; tid += 1
        return term_map[t]

    # Replace terminals in long rules
    for A, P in g.items():
        for p in P:
            if len(p) == 1:
                wrapped[A].append(p)
            else:
                q = [s if s in g else term_var(s) for s in p]
                wrapped[A].append(q)
    for t, v in term_map.items():
        wrapped[v].append([t])

    cnf, pair_cache, pid = defaultdict(list), {}, 1

    def bin_var(x, y):
        nonlocal pid
        key = (x, y)
        if key not in pair_cache:
            name = f"A{pid}"; pid += 1
            pair_cache[key] = name
            cnf[name].append([x, y])
        return pair_cache[key]

    # Right-binarise productions
    for A, P in wrapped.items():
        for p in P:
            while len(p) > 2:
                x, y = p[-2], p[-1]
                p = p[:-2] + [bin_var(x, y)]
            cnf[A].append(p)

    # Deduplicate
    for A in list(cnf):
        uniq = []
        seen = set()
        for p in cnf[A]:
            t = tuple(p)
            if t not in seen:
                seen.add(t)
                uniq.append(p)
        cnf[A] = uniq

    return dict(cnf)

def validate_cnf(g, start):
    for A, P in g.items():
        for p in P:
            if p == ['ε']:
                if A != start:
                    return False
            elif len(p) == 1:
                if p[0] in g:
                    return False
            elif len(p) == 2:
                if p[0] not in g or p[1] not in g:
                    return False
            else:
                return False
    return True

# ─── public wrappers ────────────────────────────────────
def cfg_to_cnf(text):
    G = parse_cfg(text)
    S = next(iter(G))
    log = []

    def step(lbl):
        log.append((lbl, format_grammar(G)))

    start_rhs = any(S in p for P in G.values() for p in P)
    nullable = {A for A, P in G.items() if ['ε'] in P}
    changed = True
    while changed:
        changed = False
        for A, P in G.items():
            if A in nullable:
                continue
            if any(all(s in nullable for s in q) for q in P):
                nullable.add(A); changed = True
    if start_rhs or S in nullable:
        rule = [[S]] + ([['ε']] if S in nullable else [])
        G = {**{"S0": rule}, **G}
        S = "S0"
        step("Add new start symbol")
    else:
        step("Original CFG")
    G = remove_null_productions(G, S);     step("ε-removed")
    G = remove_unit_productions(G);        step("unit-removed")
    G = remove_useless_symbols(G, S);      step("useless-removed")
    G = convert_to_cnf(G, S)
    assert validate_cnf(G, S)
    log.append(("CNF", format_grammar(G)))
    return "\\n\\n".join(f"{lbl}:\\n{body}" for lbl, body in log)

def generate_words(text, max_len=4, max_words=20):
    G = parse_cfg(text); S = next(iter(G))
    words, dq = set(), deque([[S]])
    while dq and len(words) < max_words:
        seq = dq.popleft()
        w = "".join(c for c in seq if c not in G and c != 'ε')
        if len(w) > max_len:
            continue
        if all(c not in G for c in seq):
            words.add(w); continue
        for i,s in enumerate(seq):
            if s in G:
                for p in G[s]:
                    dq.append(seq[:i] + [t for t in p if t!='ε'] + seq[i+1:])
                break
    return sorted(words)
`;
pyodide.runPython(pythonCode);

/* ========== 3 ▸ connect the buttons (JS) ========== */
const out = document.getElementById("out");
const src = document.getElementById("src");

// Map each letter to a consistent color
const colorMap = {};
const palette = [
  '#e6194b','#3cb44b','#ffe119','#0082c8','#f58231',
  '#911eb4','#46f0f0','#f032e6','#d2f53c','#fabebe',
  '#008080','#e6beff','#aa6e28','#fffac8','#800000',
  '#aaffc3','#808000','#ffd8b1','#000080','#808080',
  '#ffd700','#40e0d0','#e9967a','#f4a460','#b0c4de'
];

function getColor(c) {
  if (!colorMap[c]) {
    colorMap[c] = palette[Object.keys(colorMap).length % palette.length];
  }
  return colorMap[c];
}

function titleCase(str) {
  return str.replace(/(?:^|[-\s])(\S)/g, s => s.toUpperCase());
}

function colorize(text) {
  return text.split('\n').map(line => {
    const trimmed = line.trim();
    if (trimmed.endsWith(':') && !trimmed.includes('->')) {
      const label = titleCase(trimmed.slice(0, -1));
      return `<span style="text-decoration: underline">${label}:</span>`;
    }
    return line
      .replace(/[A-Za-z]/g, c => `<span style="color:${getColor(c)}">${c}</span>`)
      .replace(/\|/g, '<b>|</b>');
  }).join('\n');
}

document.getElementById("run").onclick = () => {
  const txt = src.value.replaceAll("\r", "");
  const result = pyodide.runPython(`cfg_to_cnf("""${txt}""")`);
  out.innerHTML = colorize(result);
};

const wordsOut = document.getElementById("words");
document.getElementById("gen").onclick = () => {
  const txt = src.value.replaceAll("\r", "");
  const words = pyodide.runPython(`generate_words("""${txt}""")`);
  const colored = words.map(w => colorize(w)).join(", ");
  wordsOut.innerHTML = "Generated words: " + colored;
};
</script>
</body>
</html>
