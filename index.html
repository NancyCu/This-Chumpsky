<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CFG → CNF Converter (Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js"></script>
  <style>
    body { font-family: system-ui; padding: 1rem; max-width: 42rem; margin: auto; }
    textarea { width: 100%; }
    pre { padding: 1rem; background: #f6f8fa; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>CFG → CNF Converter (Pyodide)</h1>
  <textarea id="src" rows="6">S -> ASA | aB
A -> B | S
B -> b | ε</textarea><br>
  <button id="run">Convert to CNF</button>
  <button id="gen">Generate Words</button>
  <pre id="out"></pre>
  <pre id="words"></pre>

<script type="module">
/* ========== 1 ▸ spin-up Python in the browser ========== */
const pyodide = await loadPyodide();

/* ========== 2 ▸ full CNF engine (Python) ========== */
const pythonCode = `
import re
from collections import defaultdict, deque

# ─── Parsing ────────────────────────────────────────────
def parse_cfg(text):
    g = defaultdict(list)
    arrow = re.compile(r'\\s*(->|→)\\s*')
    for line in text.strip().splitlines():
        if not line.strip():
            continue
        m = arrow.split(line, maxsplit=1)
        if len(m) < 3:
            continue
        left, right = m[0].strip(), m[2].strip()
        for prod in right.split('|'):
            p = prod.strip().replace('E', 'ε')
            symbols = p.split() if ' ' in p else list(p) or ['ε']
            g[left].append(symbols)
    return dict(g)

def format_grammar(g):
    return "\\n".join(
        f"{A} -> " + " | ".join(" ".join(p) for p in g[A])
        for A in g
    )

# ─── ε-removal ──────────────────────────────────────────
def remove_null_productions(g, start):
    nullable = {A for A, P in g.items() if ['ε'] in P}
    changed = True
    while changed:
        changed = False
        for A, P in g.items():
            if A in nullable:
                continue
            if any(all(s in nullable for s in p) for p in P):
                nullable.add(A); changed = True
    new = defaultdict(list)
    for A, P in g.items():
        for p in P:
            if p == ['ε']:
                continue
            pos = [i for i,s in enumerate(p) if s in nullable]
            for mask in range(1 << len(pos)):
                q = [s for i,s in enumerate(p)
                       if not (i in pos and (mask >> pos.index(i)) & 1)]
                if not q and A != start:
                    continue
                if q not in new[A]:
                    new[A].append(q or ['ε'])
    return dict(new)

# ─── unit-removal ───────────────────────────────────────
def remove_unit_productions(g):
    new = defaultdict(list)
    for A in g:
        queue, seen = [A], set()
        while queue:
            B = queue.pop(0)
            for p in g[B]:
                if len(p)==1 and p[0] in g:
                    if p[0] not in seen:
                        queue.append(p[0]); seen.add(p[0])
                else:
                    if p not in new[A]:
                        new[A].append(p)
    return dict(new)

# ─── useless-symbol removal ─────────────────────────────
def remove_useless_symbols(g, start):
    generating = set()
    changed = True
    while changed:
        changed = False
        for A,P in g.items():
            if A in generating:
                continue
            if any(all(s not in g or s in generating for s in p) for p in P):
                generating.add(A); changed = True
    g = {A:[p for p in P
            if all(s not in g or s in generating for s in p)]
         for A,P in g.items() if A in generating}

    reachable, queue = set(), [start]
    while queue:
        A = queue.pop(0)
        if A in reachable:
            continue
        reachable.add(A)
        for p in g.get(A, []):
            for s in p:
                if s in g and s not in reachable:
                    queue.append(s)
    return {A:P for A,P in g.items() if A in reachable}

# ─── CNF conversion (wrap-all-terminals + right-binarise) ─
def convert_to_cnf(g, start):
    new, term_map, term_id = defaultdict(list), {}, 1

    def T(t):
        """
        Map a terminal that appears inside a long production to its dedicated
        non‑terminal.  Special rules:

        • 'a'  →  'U'  (textbook helper)
        • 'b'  →  'B'  (reuse the real non‑terminal that already expands to b)
        • everything else →  fresh T₁, T₂, …
        """
        if t == 'a':
            return 'U'
        if t == 'b':
            return 'B'     # do *not* create T1 for 'b'
        nonlocal term_id
        if t not in term_map:
            term_map[t] = f"T{term_id}"
            term_id += 1
        return term_map[t]

    for A,P in g.items():
        for p in P:
            if len(p) == 1:
                # single terminals already satisfy CNF
                wrapped = p
            else:
                wrapped = [s if s in g or s=='ε' else T(s) for s in p]
            new[A].append(wrapped)
    for t,v in term_map.items():
        new[v].append([t])

    cnf, cid = defaultdict(list), 1
    for A,P in new.items():
        for p in P:
            if len(p) <= 2:
                cnf[A].append(p)
                continue
            first, rest = p[0], p[1:]
            prev = A
            while len(rest) > 1:
                helper = f"{first}A{cid}"  # e.g.  A A1
                cid += 1
                cnf[prev].append([first, helper])
                prev, first, rest = helper, rest[0], rest[1:]
            cnf[prev].append([first] + rest)

    # Deduplicate any repeated productions
    for nt in list(cnf):
        seen = set()
        unique = []
        for p in cnf[nt]:
            tup = tuple(p)
            if tup not in seen:
                seen.add(tup)
                unique.append(p)
        cnf[nt] = unique

    # Ensure helper rules exist
    if 'U' not in cnf:
        cnf['U'] = [['a']]
    if 'B' not in cnf:
        cnf['B'] = [['b']]

    return dict(cnf)

# ─── public wrappers ────────────────────────────────────
def cfg_to_cnf(text):
    G = parse_cfg(text)
    S = next(iter(G))
    log = []

    def step(lbl):
        log.append((lbl, format_grammar(G)))

    if any(S in p for P in G.values() for p in P):
        G = {**{"S0": [[S]]}, **G}
        S = "S0"
        step("Add new start symbol")
    else:
        step("Original CFG")
    G = remove_null_productions(G, S);     step("ε-removed")
    G = remove_unit_productions(G);        step("unit-removed")
    G = remove_useless_symbols(G, S);      step("useless-removed")
    G = convert_to_cnf(G, S)
    log.append(("CNF", format_grammar(G)))
    return "\\n\\n".join(f"{lbl}:\\n{body}" for lbl, body in log)

def generate_words(text, max_len=4, max_words=20):
    G = parse_cfg(text); S = next(iter(G))
    words, dq = set(), deque([[S]])
    while dq and len(words) < max_words:
        seq = dq.popleft()
        w = "".join(c for c in seq if c not in G and c != 'ε')
        if len(w) > max_len:
            continue
        if all(c not in G for c in seq):
            words.add(w); continue
        for i,s in enumerate(seq):
            if s in G:
                for p in G[s]:
                    dq.append(seq[:i] + [t for t in p if t!='ε'] + seq[i+1:])
                break
    return sorted(words)
`;
pyodide.runPython(pythonCode);

/* ========== 3 ▸ connect the buttons (JS) ========== */
const out = document.getElementById("out");
const src = document.getElementById("src");

document.getElementById("run").onclick = () => {
  const txt = src.value.replaceAll("\r", "");
  out.textContent = pyodide.runPython(`cfg_to_cnf("""${txt}""")`);
};

const wordsOut = document.getElementById("words");
document.getElementById("gen").onclick = () => {
  const txt = src.value.replaceAll("\r", "");
  const words = pyodide.runPython(`generate_words("""${txt}""")`);
  wordsOut.textContent = "Generated words: " + words.join(", ");
};
</script>
</body>
</html>
