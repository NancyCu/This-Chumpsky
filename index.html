<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CFG → CNF Converter (Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js"></script>
  <style>
    body { font-family: system-ui; padding: 1rem; max-width: 42rem; margin: auto; }
    textarea { width: 100%; }
    pre { padding: 1rem; background: #f6f8fa; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>CFG → CNF Converter (Pyodide)</h1>
  <textarea id="src" rows="6">S -> ASA | aB
A -> B | S
B -> b | ε</textarea><br>
  <button id="run">Convert to CNF</button>
  <button id="gen">Generate Words</button>
  <pre id="out"></pre>
  <pre id="words"></pre>

<script type="module">
/* ========== 1 ▸ spin-up Python in the browser ========== */
const pyodide = await loadPyodide();

/* ========== 2 ▸ full CNF engine (Python) ========== */
const pythonCode = `
import re
from collections import defaultdict, deque

# ─── Parsing ────────────────────────────────────────────
def parse_cfg(text):
    g = defaultdict(list)
    arrow = re.compile(r'\\s*(->|→)\\s*')
    for line in text.strip().splitlines():
        if not line.strip():
            continue
        m = arrow.split(line, maxsplit=1)
        if len(m) < 3:
            continue
        left, right = m[0].strip(), m[2].strip()
        for prod in right.split('|'):
            prod = prod.strip()
            if prod in ('ε', 'E', '', '𝜺'):
                g[left].append(['ε'])
                continue
            if ' ' in prod:
                symbols = [tok.strip() for tok in prod.split() if tok.strip()]
            else:
                symbols = list(prod)
            g[left].append(symbols)
    return dict(g)

def format_grammar(g):
    return "\\n".join(
        f"{A} -> " + " | ".join(" ".join(p) for p in g[A])
        for A in g
    )

# ─── ε-removal ──────────────────────────────────────────
def remove_null_productions(g, start):
    nullable = {A for A, P in g.items() if ['ε'] in P}
    changed = True
    while changed:
        changed = False
        for A, P in g.items():
            if A in nullable:
                continue
            if any(all(s in nullable for s in p) for p in P):
                nullable.add(A); changed = True
    new = defaultdict(list)
    for A, P in g.items():
        for p in P:
            if p == ['ε']:
                continue
            pos = [i for i,s in enumerate(p) if s in nullable]
            for mask in range(1 << len(pos)):
                q = [s for i,s in enumerate(p)
                       if not (i in pos and (mask >> pos.index(i)) & 1)]
                if not q and A != start:
                    continue
                if q not in new[A]:
                    new[A].append(q or ['ε'])
    return dict(new)

# ─── unit-removal ───────────────────────────────────────
def remove_unit_productions(g):
    new = defaultdict(list)
    for A in g:
        queue, seen = [A], set()
        while queue:
            B = queue.pop(0)
            for p in g[B]:
                if len(p)==1 and p[0] in g:
                    if p[0] not in seen:
                        queue.append(p[0]); seen.add(p[0])
                else:
                    if p not in new[A]:
                        new[A].append(p)
    return dict(new)

# ─── useless-symbol removal ─────────────────────────────
def remove_useless_symbols(g, start):
    generating = set()
    changed = True
    while changed:
        changed = False
        for A,P in g.items():
            if A in generating:
                continue
            if any(all(s not in g or s in generating for s in p) for p in P):
                generating.add(A); changed = True
    g = {A:[p for p in P
            if all(s not in g or s in generating for s in p)]
         for A,P in g.items() if A in generating}

    reachable, queue = set(), [start]
    while queue:
        A = queue.pop(0)
        if A in reachable:
            continue
        reachable.add(A)
        for p in g.get(A, []):
            for s in p:
                if s in g and s not in reachable:
                    queue.append(s)
    return {A:P for A,P in g.items() if A in reachable}

# ─── CNF conversion (wrap-all-terminals + right-binarise) ─
def convert_to_cnf(g, start):
    wrapped, term_map, tid = defaultdict(list), {}, 1

    def term_var(t):
        nonlocal tid
        if t not in term_map:
            term_map[t] = f"T{tid}"; tid += 1
        return term_map[t]

    # Replace terminals in long rules
    for A, P in g.items():
        for p in P:
            if len(p) == 1:
                wrapped[A].append(p)
            else:
                q = [s if s in g else term_var(s) for s in p]
                wrapped[A].append(q)
    for t, v in term_map.items():
        wrapped[v].append([t])

    cnf, pair_cache, pid = defaultdict(list), {}, 1

    def bin_var(x, y):
        nonlocal pid
        key = (x, y)
        if key not in pair_cache:
            name = f"A{pid}"; pid += 1
            pair_cache[key] = name
            cnf[name].append([x, y])
        return pair_cache[key]

    # Right-binarise productions
    for A, P in wrapped.items():
        for p in P:
            while len(p) > 2:
                x, y = p[-2], p[-1]
                p = p[:-2] + [bin_var(x, y)]
            cnf[A].append(p)

    # Deduplicate
    for A in list(cnf):
        uniq = []
        seen = set()
        for p in cnf[A]:
            t = tuple(p)
            if t not in seen:
                seen.add(t)
                uniq.append(p)
        cnf[A] = uniq

    return dict(cnf)

def validate_cnf(g, start):
    for A, P in g.items():
        for p in P:
            if p == ['ε']:
                if A != start:
                    return False
            elif len(p) == 1:
                if p[0] in g:
                    return False
            elif len(p) == 2:
                if p[0] not in g or p[1] not in g:
                    return False
            else:
                return False
    return True

# ─── public wrappers ────────────────────────────────────
def cfg_to_cnf(text):
    G = parse_cfg(text)
    S = next(iter(G))
    log = []

    def step(lbl):
        log.append((lbl, format_grammar(G)))

    if any(S in p for P in G.values() for p in P):
        G = {**{"S0": [[S]]}, **G}
        S = "S0"
        step("Add new start symbol")
    else:
        step("Original CFG")
    G = remove_null_productions(G, S);     step("ε-removed")
    G = remove_unit_productions(G);        step("unit-removed")
    G = remove_useless_symbols(G, S);      step("useless-removed")
    G = convert_to_cnf(G, S)
    assert validate_cnf(G, S)
    log.append(("CNF", format_grammar(G)))
    return "\\n\\n".join(f"{lbl}:\\n{body}" for lbl, body in log)

def generate_words(text, max_len=4, max_words=20):
    G = parse_cfg(text); S = next(iter(G))
    words, dq = set(), deque([[S]])
    while dq and len(words) < max_words:
        seq = dq.popleft()
        w = "".join(c for c in seq if c not in G and c != 'ε')
        if len(w) > max_len:
            continue
        if all(c not in G for c in seq):
            words.add(w); continue
        for i,s in enumerate(seq):
            if s in G:
                for p in G[s]:
                    dq.append(seq[:i] + [t for t in p if t!='ε'] + seq[i+1:])
                break
    return sorted(words)
`;
pyodide.runPython(pythonCode);

/* ========== 3 ▸ connect the buttons (JS) ========== */
const out = document.getElementById("out");
const src = document.getElementById("src");

document.getElementById("run").onclick = () => {
  const txt = src.value.replaceAll("\r", "");
  out.textContent = pyodide.runPython(`cfg_to_cnf("""${txt}""")`);
};

const wordsOut = document.getElementById("words");
document.getElementById("gen").onclick = () => {
  const txt = src.value.replaceAll("\r", "");
  const words = pyodide.runPython(`generate_words("""${txt}""")`);
  wordsOut.textContent = "Generated words: " + words.join(", ");
};
</script>
</body>
</html>
